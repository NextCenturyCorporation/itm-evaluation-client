# coding: utf-8

"""
    ITM TA3 API

    This is the specification of the TA3 API for In The Moment (ITM).  Currently, the Evaluation API for TA2 supports functionality for the September milestone.  The API is based on the OpenAPI 3.0 specification.  # noqa: E501

    OpenAPI spec version: 0.3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Scene(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'index': 'int',
        'state': 'State',
        'end_scene_allowed': 'bool',
        'probe_config': 'list[ProbeConfig]',
        'tagging': 'Tagging',
        'action_mapping': 'list[ActionMapping]',
        'restricted_actions': 'list[ActionTypeEnum]',
        'transition_semantics': 'SemanticTypeEnum',
        'transitions': 'Conditions'
    }

    attribute_map = {
        'index': 'index',
        'state': 'state',
        'end_scene_allowed': 'end_scene_allowed',
        'probe_config': 'probe_config',
        'tagging': 'tagging',
        'action_mapping': 'action_mapping',
        'restricted_actions': 'restricted_actions',
        'transition_semantics': 'transition_semantics',
        'transitions': 'transitions'
    }

    def __init__(self, index=None, state=None, end_scene_allowed=None, probe_config=None, tagging=None, action_mapping=None, restricted_actions=None, transition_semantics=None, transitions=None):  # noqa: E501
        """Scene - a model defined in Swagger"""  # noqa: E501
        self._index = None
        self._state = None
        self._end_scene_allowed = None
        self._probe_config = None
        self._tagging = None
        self._action_mapping = None
        self._restricted_actions = None
        self._transition_semantics = None
        self._transitions = None
        self.discriminator = None
        self.index = index
        if state is not None:
            self.state = state
        self.end_scene_allowed = end_scene_allowed
        if probe_config is not None:
            self.probe_config = probe_config
        if tagging is not None:
            self.tagging = tagging
        self.action_mapping = action_mapping
        if restricted_actions is not None:
            self.restricted_actions = restricted_actions
        if transition_semantics is not None:
            self.transition_semantics = transition_semantics
        if transitions is not None:
            self.transitions = transitions

    @property
    def index(self):
        """Gets the index of this Scene.  # noqa: E501

        The order the scene appears in the scenario  # noqa: E501

        :return: The index of this Scene.  # noqa: E501
        :rtype: int
        """
        return self._index

    @index.setter
    def index(self, index):
        """Sets the index of this Scene.

        The order the scene appears in the scenario  # noqa: E501

        :param index: The index of this Scene.  # noqa: E501
        :type: int
        """
        if index is None:
            raise ValueError("Invalid value for `index`, must not be `None`")  # noqa: E501

        self._index = index

    @property
    def state(self):
        """Gets the state of this Scene.  # noqa: E501


        :return: The state of this Scene.  # noqa: E501
        :rtype: State
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Scene.


        :param state: The state of this Scene.  # noqa: E501
        :type: State
        """

        self._state = state

    @property
    def end_scene_allowed(self):
        """Gets the end_scene_allowed of this Scene.  # noqa: E501

        Whether ADMs can explicitly end the scene  # noqa: E501

        :return: The end_scene_allowed of this Scene.  # noqa: E501
        :rtype: bool
        """
        return self._end_scene_allowed

    @end_scene_allowed.setter
    def end_scene_allowed(self, end_scene_allowed):
        """Sets the end_scene_allowed of this Scene.

        Whether ADMs can explicitly end the scene  # noqa: E501

        :param end_scene_allowed: The end_scene_allowed of this Scene.  # noqa: E501
        :type: bool
        """
        if end_scene_allowed is None:
            raise ValueError("Invalid value for `end_scene_allowed`, must not be `None`")  # noqa: E501

        self._end_scene_allowed = end_scene_allowed

    @property
    def probe_config(self):
        """Gets the probe_config of this Scene.  # noqa: E501

        TA1-provided probe configuration, ignored by TA3  # noqa: E501

        :return: The probe_config of this Scene.  # noqa: E501
        :rtype: list[ProbeConfig]
        """
        return self._probe_config

    @probe_config.setter
    def probe_config(self, probe_config):
        """Sets the probe_config of this Scene.

        TA1-provided probe configuration, ignored by TA3  # noqa: E501

        :param probe_config: The probe_config of this Scene.  # noqa: E501
        :type: list[ProbeConfig]
        """

        self._probe_config = probe_config

    @property
    def tagging(self):
        """Gets the tagging of this Scene.  # noqa: E501


        :return: The tagging of this Scene.  # noqa: E501
        :rtype: Tagging
        """
        return self._tagging

    @tagging.setter
    def tagging(self, tagging):
        """Sets the tagging of this Scene.


        :param tagging: The tagging of this Scene.  # noqa: E501
        :type: Tagging
        """

        self._tagging = tagging

    @property
    def action_mapping(self):
        """Gets the action_mapping of this Scene.  # noqa: E501

        List of actions with details of how those actions map to probe responses  # noqa: E501

        :return: The action_mapping of this Scene.  # noqa: E501
        :rtype: list[ActionMapping]
        """
        return self._action_mapping

    @action_mapping.setter
    def action_mapping(self, action_mapping):
        """Sets the action_mapping of this Scene.

        List of actions with details of how those actions map to probe responses  # noqa: E501

        :param action_mapping: The action_mapping of this Scene.  # noqa: E501
        :type: list[ActionMapping]
        """
        if action_mapping is None:
            raise ValueError("Invalid value for `action_mapping`, must not be `None`")  # noqa: E501

        self._action_mapping = action_mapping

    @property
    def restricted_actions(self):
        """Gets the restricted_actions of this Scene.  # noqa: E501

        List of actions that will be excluded from get_available_actions  # noqa: E501

        :return: The restricted_actions of this Scene.  # noqa: E501
        :rtype: list[ActionTypeEnum]
        """
        return self._restricted_actions

    @restricted_actions.setter
    def restricted_actions(self, restricted_actions):
        """Sets the restricted_actions of this Scene.

        List of actions that will be excluded from get_available_actions  # noqa: E501

        :param restricted_actions: The restricted_actions of this Scene.  # noqa: E501
        :type: list[ActionTypeEnum]
        """

        self._restricted_actions = restricted_actions

    @property
    def transition_semantics(self):
        """Gets the transition_semantics of this Scene.  # noqa: E501


        :return: The transition_semantics of this Scene.  # noqa: E501
        :rtype: SemanticTypeEnum
        """
        return self._transition_semantics

    @transition_semantics.setter
    def transition_semantics(self, transition_semantics):
        """Sets the transition_semantics of this Scene.


        :param transition_semantics: The transition_semantics of this Scene.  # noqa: E501
        :type: SemanticTypeEnum
        """

        self._transition_semantics = transition_semantics

    @property
    def transitions(self):
        """Gets the transitions of this Scene.  # noqa: E501


        :return: The transitions of this Scene.  # noqa: E501
        :rtype: Conditions
        """
        return self._transitions

    @transitions.setter
    def transitions(self, transitions):
        """Sets the transitions of this Scene.


        :param transitions: The transitions of this Scene.  # noqa: E501
        :type: Conditions
        """

        self._transitions = transitions

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Scene, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Scene):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
