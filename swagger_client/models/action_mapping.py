# coding: utf-8

"""
    ITM TA3 API

    This is the specification of the TA3 API for In The Moment (ITM).  Currently, the Evaluation API for TA2 supports functionality for the September milestone.  The API is based on the OpenAPI 3.0 specification.  # noqa: E501

    OpenAPI spec version: 0.3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class ActionMapping(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'action_id': 'str',
        'action_type': 'ActionTypeEnum',
        'unstructured': 'str',
        'repeatable': 'bool',
        'character_id': 'str',
        'parameters': 'dict(str, str)',
        'probe_id': 'str',
        'choice': 'str',
        'next_scene': 'str',
        'kdma_association': 'dict(str, float)',
        'condition_semantics': 'SemanticTypeEnum',
        'conditions': 'Conditions'
    }

    attribute_map = {
        'action_id': 'action_id',
        'action_type': 'action_type',
        'unstructured': 'unstructured',
        'repeatable': 'repeatable',
        'character_id': 'character_id',
        'parameters': 'parameters',
        'probe_id': 'probe_id',
        'choice': 'choice',
        'next_scene': 'next_scene',
        'kdma_association': 'kdma_association',
        'condition_semantics': 'condition_semantics',
        'conditions': 'conditions'
    }

    def __init__(self, action_id=None, action_type=None, unstructured=None, repeatable=False, character_id=None, parameters=None, probe_id=None, choice=None, next_scene=None, kdma_association=None, condition_semantics=None, conditions=None):  # noqa: E501
        """ActionMapping - a model defined in Swagger"""  # noqa: E501
        self._action_id = None
        self._action_type = None
        self._unstructured = None
        self._repeatable = None
        self._character_id = None
        self._parameters = None
        self._probe_id = None
        self._choice = None
        self._next_scene = None
        self._kdma_association = None
        self._condition_semantics = None
        self._conditions = None
        self.discriminator = None
        self.action_id = action_id
        self.action_type = action_type
        self.unstructured = unstructured
        if repeatable is not None:
            self.repeatable = repeatable
        if character_id is not None:
            self.character_id = character_id
        if parameters is not None:
            self.parameters = parameters
        self.probe_id = probe_id
        self.choice = choice
        if next_scene is not None:
            self.next_scene = next_scene
        if kdma_association is not None:
            self.kdma_association = kdma_association
        if condition_semantics is not None:
            self.condition_semantics = condition_semantics
        if conditions is not None:
            self.conditions = conditions

    @property
    def action_id(self):
        """Gets the action_id of this ActionMapping.  # noqa: E501

        A unique action ID within the scenario  # noqa: E501

        :return: The action_id of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._action_id

    @action_id.setter
    def action_id(self, action_id):
        """Sets the action_id of this ActionMapping.

        A unique action ID within the scenario  # noqa: E501

        :param action_id: The action_id of this ActionMapping.  # noqa: E501
        :type: str
        """
        if action_id is None:
            raise ValueError("Invalid value for `action_id`, must not be `None`")  # noqa: E501

        self._action_id = action_id

    @property
    def action_type(self):
        """Gets the action_type of this ActionMapping.  # noqa: E501


        :return: The action_type of this ActionMapping.  # noqa: E501
        :rtype: ActionTypeEnum
        """
        return self._action_type

    @action_type.setter
    def action_type(self, action_type):
        """Sets the action_type of this ActionMapping.


        :param action_type: The action_type of this ActionMapping.  # noqa: E501
        :type: ActionTypeEnum
        """
        if action_type is None:
            raise ValueError("Invalid value for `action_type`, must not be `None`")  # noqa: E501

        self._action_type = action_type

    @property
    def unstructured(self):
        """Gets the unstructured of this ActionMapping.  # noqa: E501

        Natural language, plain text description of the action  # noqa: E501

        :return: The unstructured of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._unstructured

    @unstructured.setter
    def unstructured(self, unstructured):
        """Sets the unstructured of this ActionMapping.

        Natural language, plain text description of the action  # noqa: E501

        :param unstructured: The unstructured of this ActionMapping.  # noqa: E501
        :type: str
        """
        if unstructured is None:
            raise ValueError("Invalid value for `unstructured`, must not be `None`")  # noqa: E501

        self._unstructured = unstructured

    @property
    def repeatable(self):
        """Gets the repeatable of this ActionMapping.  # noqa: E501

        Whether or not this action should remain after it's selected by an ADM  # noqa: E501

        :return: The repeatable of this ActionMapping.  # noqa: E501
        :rtype: bool
        """
        return self._repeatable

    @repeatable.setter
    def repeatable(self, repeatable):
        """Sets the repeatable of this ActionMapping.

        Whether or not this action should remain after it's selected by an ADM  # noqa: E501

        :param repeatable: The repeatable of this ActionMapping.  # noqa: E501
        :type: bool
        """

        self._repeatable = repeatable

    @property
    def character_id(self):
        """Gets the character_id of this ActionMapping.  # noqa: E501

        The ID of the character being acted upon  # noqa: E501

        :return: The character_id of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._character_id

    @character_id.setter
    def character_id(self, character_id):
        """Sets the character_id of this ActionMapping.

        The ID of the character being acted upon  # noqa: E501

        :param character_id: The character_id of this ActionMapping.  # noqa: E501
        :type: str
        """

        self._character_id = character_id

    @property
    def parameters(self):
        """Gets the parameters of this ActionMapping.  # noqa: E501

        key-value pairs containing additional [action-specific parameters](https://github.com/NextCenturyCorporation/itm-evaluation-client?tab=readme-ov-file#available-actions)  # noqa: E501

        :return: The parameters of this ActionMapping.  # noqa: E501
        :rtype: dict(str, str)
        """
        return self._parameters

    @parameters.setter
    def parameters(self, parameters):
        """Sets the parameters of this ActionMapping.

        key-value pairs containing additional [action-specific parameters](https://github.com/NextCenturyCorporation/itm-evaluation-client?tab=readme-ov-file#available-actions)  # noqa: E501

        :param parameters: The parameters of this ActionMapping.  # noqa: E501
        :type: dict(str, str)
        """

        self._parameters = parameters

    @property
    def probe_id(self):
        """Gets the probe_id of this ActionMapping.  # noqa: E501

        A valid probe_id from the appropriate TA1  # noqa: E501

        :return: The probe_id of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._probe_id

    @probe_id.setter
    def probe_id(self, probe_id):
        """Sets the probe_id of this ActionMapping.

        A valid probe_id from the appropriate TA1  # noqa: E501

        :param probe_id: The probe_id of this ActionMapping.  # noqa: E501
        :type: str
        """
        if probe_id is None:
            raise ValueError("Invalid value for `probe_id`, must not be `None`")  # noqa: E501

        self._probe_id = probe_id

    @property
    def choice(self):
        """Gets the choice of this ActionMapping.  # noqa: E501

        A valid choice for the specified probe_id  # noqa: E501

        :return: The choice of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._choice

    @choice.setter
    def choice(self, choice):
        """Sets the choice of this ActionMapping.

        A valid choice for the specified probe_id  # noqa: E501

        :param choice: The choice of this ActionMapping.  # noqa: E501
        :type: str
        """
        if choice is None:
            raise ValueError("Invalid value for `choice`, must not be `None`")  # noqa: E501

        self._choice = choice

    @property
    def next_scene(self):
        """Gets the next_scene of this ActionMapping.  # noqa: E501

        The ID of the next scene in the scenario; overrides Scene.next_scene  # noqa: E501

        :return: The next_scene of this ActionMapping.  # noqa: E501
        :rtype: str
        """
        return self._next_scene

    @next_scene.setter
    def next_scene(self, next_scene):
        """Sets the next_scene of this ActionMapping.

        The ID of the next scene in the scenario; overrides Scene.next_scene  # noqa: E501

        :param next_scene: The next_scene of this ActionMapping.  # noqa: E501
        :type: str
        """

        self._next_scene = next_scene

    @property
    def kdma_association(self):
        """Gets the kdma_association of this ActionMapping.  # noqa: E501

        KDMA associations for this choice, if provided by TA1  # noqa: E501

        :return: The kdma_association of this ActionMapping.  # noqa: E501
        :rtype: dict(str, float)
        """
        return self._kdma_association

    @kdma_association.setter
    def kdma_association(self, kdma_association):
        """Sets the kdma_association of this ActionMapping.

        KDMA associations for this choice, if provided by TA1  # noqa: E501

        :param kdma_association: The kdma_association of this ActionMapping.  # noqa: E501
        :type: dict(str, float)
        """

        self._kdma_association = kdma_association

    @property
    def condition_semantics(self):
        """Gets the condition_semantics of this ActionMapping.  # noqa: E501


        :return: The condition_semantics of this ActionMapping.  # noqa: E501
        :rtype: SemanticTypeEnum
        """
        return self._condition_semantics

    @condition_semantics.setter
    def condition_semantics(self, condition_semantics):
        """Sets the condition_semantics of this ActionMapping.


        :param condition_semantics: The condition_semantics of this ActionMapping.  # noqa: E501
        :type: SemanticTypeEnum
        """

        self._condition_semantics = condition_semantics

    @property
    def conditions(self):
        """Gets the conditions of this ActionMapping.  # noqa: E501


        :return: The conditions of this ActionMapping.  # noqa: E501
        :rtype: Conditions
        """
        return self._conditions

    @conditions.setter
    def conditions(self, conditions):
        """Sets the conditions of this ActionMapping.


        :param conditions: The conditions of this ActionMapping.  # noqa: E501
        :type: Conditions
        """

        self._conditions = conditions

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ActionMapping, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ActionMapping):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
